source("gom_jml_mod.R",local = T)
setwd("D:/Programmes/Covariate-Assisted-Spectral-GoM")
library(RSpectra)
library(Rfast)
library(Matrix)
library(gtools)
# library(sirt)
library(tictoc)
source("gom_jml_mod.R")
tic()
res.jml = gom.jml(data.frame(A),K)
## data generation
K = 3
N = 500
p = N/5
R = 2
Pi = matrix(rep(0,N*K),nrow=N)
Theta = matrix(rep(0,p*K),ncol=K)
M = matrix(rnorm(R*K),nrow=R)
idx.all = permutation(1:K)
pi_gen <- function(pi,K){
pi = rdirichlet(1,rep(1,K))
return(pi)
}
theta_gen <- function(theta,K){
theta = runif(K)
return(theta)
}
set.seed(230625)
Pi = t(apply(Pi,1,pi_gen,K=K))
Theta = t(apply(Theta,1,theta_gen,K=K))
Pi[1:K,] = diag(rep(1,K))
A_t = Pi%*%t(Theta)
X_t = Pi%*%t(M)
A = matrix(rbinom(N*p,1,A_t),nrow = N)
X = X_t + matrix(rnorm(N*R,0,1),nrow=N)
## tuning parameter (The choice is still undecided)
alpha = .1
## functions
find_knn_x <- function(vec,U,r){
U1 = transpose(transpose(U)-vec)
d = apply(U1,1,norm,"2")
d = sort(d)
x = mean(d[1:(r+1)])
return(x)
}
Prune <- function(U,r,q,e){
l = apply(U,1,norm,"2")
quan.l = quantile(l,1-q)
P0 = which(l>=quan.l)
U0 = U[P0,]
x = apply(U0,1,find_knn_x,U=U,r=r)
quan.x = quantile(x,1-e)
P = which(x>quan.x)
P = P0[P]
return(P)
}
find_act <- function(s,P){
s+sum(P<s)
}
null_cluster <- function(A,K,r,q,e,eps=1e-3){
svd.A = svds(A,K)
P = Prune(svd.A$u,r,q,e)
IK = Diag.matrix(K,1)
S = c()
U = svd.A$u
Y0 = U[-P,]
Y = Y0
for (k in 1:K) {
l = apply(Y,1,norm,"2")
S = c(S,which.max(l))
u = Y[S[k],]/norm(Y[S[k],],"2")
u = data.matrix(u)
Y = mat.mult(Y,IK-mat.mult(u,transpose(u)))
}
US = Y0[S,]
Pi = mat.mult(U,solve(US))
Pi = pmax(Pi,0)
Pi = mat.mult(diag(rowsums(Pi)^(-1)),Pi)
Theta = mat.mult(mat.mult(mat.mult(mat.mult(svd.A$v,diag(svd.A$d)),transpose(svd.A$u)),Pi),spdinv(mat.mult(transpose(Pi),Pi)))
Theta = pmax(Theta,1-eps)
Theta = pmin(Theta,eps)
S = lapply(S,find_act,P)
return(list(Pi=Pi,Theta=Theta,S=S))
}
cov_cluster <- function(A,X,K,alpha,r,q,e,eps=1e-3){
L = mat.mult(A,transpose(A))+alpha*mat.mult(X,transpose(X))
L = Diag.fill(L,0)
evd.A = eigs(L,K)
P = Prune(evd.A$vectors,r,q,e)
IK = Diag.matrix(K,1)
U = evd.A$vectors
S = c()
Y0 = U[-P,]
Y = Y0
for (k in 1:K) {
l = apply(Y,1,norm,"2")
S = c(S,which.max(l))
u = Y[S[k],]/norm(Y[S[k],],"2")
u = data.matrix(u)
Y = mat.mult(Y,IK-mat.mult(u,transpose(u)))
}
US = Y0[S,]
Pi = mat.mult(U,solve(US))
Pi = pmax(Pi,0)
Pi = mat.mult(diag(rowsums(Pi)^(-1)),Pi)
svd.A = svds(A,K)
Theta = mat.mult(mat.mult(mat.mult(mat.mult(svd.A$v,diag(svd.A$d)),transpose(svd.A$u)),Pi),spdinv(mat.mult(transpose(Pi),Pi)))
Theta = pmax(Theta,1-eps)
Theta = pmin(Theta,eps)
S = lapply(S,find_act,P)
return(list(Pi=Pi,Theta=Theta,S=S))
}
## diag deletion
r = 10
q = .05
e = .05
tic()
res.jml = gom.jml(data.frame(A),K)
toc()
#-*- coding:utf-8 -*-
library(RSpectra)
library(Rfast)
library(Matrix)
library(gtools)
library(sirt)
library(tictoc)
# source("gom_jml_mod.R")
## data generation
K = 3
N = 500
p = N/5
R = 2
Pi = matrix(rep(0,N*K),nrow=N)
Theta = matrix(rep(0,p*K),ncol=K)
M = matrix(rnorm(R*K),nrow=R)
idx.all = permutation(1:K)
pi_gen <- function(pi,K){
pi = rdirichlet(1,rep(1,K))
return(pi)
}
theta_gen <- function(theta,K){
theta = runif(K)
return(theta)
}
set.seed(230625)
Pi = t(apply(Pi,1,pi_gen,K=K))
Theta = t(apply(Theta,1,theta_gen,K=K))
Pi[1:K,] = diag(rep(1,K))
A_t = Pi%*%t(Theta)
X_t = Pi%*%t(M)
A = matrix(rbinom(N*p,1,A_t),nrow = N)
X = X_t + matrix(rnorm(N*R,0,1),nrow=N)
## tuning parameter (The choice is still undecided)
alpha = .1
## functions
find_knn_x <- function(vec,U,r){
U1 = transpose(transpose(U)-vec)
d = apply(U1,1,norm,"2")
d = sort(d)
x = mean(d[1:(r+1)])
return(x)
}
Prune <- function(U,r,q,e){
l = apply(U,1,norm,"2")
quan.l = quantile(l,1-q)
P0 = which(l>=quan.l)
U0 = U[P0,]
x = apply(U0,1,find_knn_x,U=U,r=r)
quan.x = quantile(x,1-e)
P = which(x>quan.x)
P = P0[P]
return(P)
}
find_act <- function(s,P){
s+sum(P<s)
}
null_cluster <- function(A,K,r,q,e,eps=1e-3){
svd.A = svds(A,K)
P = Prune(svd.A$u,r,q,e)
IK = Diag.matrix(K,1)
S = c()
U = svd.A$u
Y0 = U[-P,]
Y = Y0
for (k in 1:K) {
l = apply(Y,1,norm,"2")
S = c(S,which.max(l))
u = Y[S[k],]/norm(Y[S[k],],"2")
u = data.matrix(u)
Y = mat.mult(Y,IK-mat.mult(u,transpose(u)))
}
US = Y0[S,]
Pi = mat.mult(U,solve(US))
Pi = pmax(Pi,0)
Pi = mat.mult(diag(rowsums(Pi)^(-1)),Pi)
Theta = mat.mult(mat.mult(mat.mult(mat.mult(svd.A$v,diag(svd.A$d)),transpose(svd.A$u)),Pi),spdinv(mat.mult(transpose(Pi),Pi)))
Theta = pmax(Theta,1-eps)
Theta = pmin(Theta,eps)
S = lapply(S,find_act,P)
return(list(Pi=Pi,Theta=Theta,S=S))
}
cov_cluster <- function(A,X,K,alpha,r,q,e,eps=1e-3){
L = mat.mult(A,transpose(A))+alpha*mat.mult(X,transpose(X))
L = Diag.fill(L,0)
evd.A = eigs(L,K)
P = Prune(evd.A$vectors,r,q,e)
IK = Diag.matrix(K,1)
U = evd.A$vectors
S = c()
Y0 = U[-P,]
Y = Y0
for (k in 1:K) {
l = apply(Y,1,norm,"2")
S = c(S,which.max(l))
u = Y[S[k],]/norm(Y[S[k],],"2")
u = data.matrix(u)
Y = mat.mult(Y,IK-mat.mult(u,transpose(u)))
}
US = Y0[S,]
Pi = mat.mult(U,solve(US))
Pi = pmax(Pi,0)
Pi = mat.mult(diag(rowsums(Pi)^(-1)),Pi)
svd.A = svds(A,K)
Theta = mat.mult(mat.mult(mat.mult(mat.mult(svd.A$v,diag(svd.A$d)),transpose(svd.A$u)),Pi),spdinv(mat.mult(transpose(Pi),Pi)))
Theta = pmax(Theta,1-eps)
Theta = pmin(Theta,eps)
S = lapply(S,find_act,P)
return(list(Pi=Pi,Theta=Theta,S=S))
}
## diag deletion
r = 10
q = .05
e = .05
AA = mat.mult(A,transpose(A))
AA = Diag.fill(AA,0)
XX = mat.mult(X,transpose(X))
XX = Diag.fill(XX,0)
AA.svd = svds(AA,K+1)
XX.svd = svds(XX,K+1)
alpha_seq = seq(from=.05,to=1,length=100)
within_var = rep(0,length(alpha_seq))
for (i in 1:length(alpha_seq)) {
L.cov = mat.mult(A,transpose(A))+alpha_seq[i]*mat.mult(X,transpose(X))
L.all = Diag.fill(L.cov,0)
evd.all = eigs(L.all,k=K)
kmeans.all = kmeans(evd.all$vectors,K,algorithm = "Lloyd", nstart = 2,iter.max = 100)
within_var[i] = kmeans.all$tot.withinss
}
plot(alpha_seq,within_var)
?kmeans
for (i in 1:length(alpha_seq)) {
L.cov = mat.mult(A,transpose(A))+alpha_seq[i]*mat.mult(X,transpose(X))
L.all = Diag.fill(L.cov,0)
evd.all = eigs(L.all,k=K)
kmeans.all = kmeans(evd.all$vectors,K,algorithm = "Lloyd", nstart = 1,iter.max = 100)
within_var[i] = kmeans.all$tot.withinss
}
plot(alpha_seq,within_var)
which.min(within_var)
alpha_seq[12]
for (i in 1:length(alpha_seq)) {
L.cov = mat.mult(A,transpose(A))+alpha_seq[i]*mat.mult(X,transpose(X))
L.all = Diag.fill(L.cov,0)
evd.all = eigs(L.all,k=K)
kmeans.all = kmeans(evd.all$vectors,K,algorithm = "Lloyd", nstart = 3,iter.max = 100)
within_var[i] = kmeans.all$tot.withinss
}
plot(alpha_seq,within_var)
res.cov = cov_cluster(A,X,K,alpha,r,q,e)
head(res.cov$Pi)
head(Pi)
l1.cov = norm(Pi-res.cov$Pi,"1")
l1.cov
l2.cov = norm(Pi-res.cov$Pi[,idx.cov],"2")
l2.cov = norm(Pi-res.cov$Pi,"2")
linfty.cov = max(abs(Pi-res.cov$Pi))
l2.cov
linfty.cov
res.cv = lapply(alpha_seq,cov_cluster,A=A,X=X,K=K,r=r,q=q,e=e)
alpha_seq
res.cv = sapply(alpha_seq,cov_cluster,A=A,X=X,K=K,r=r,q=q,e=e)
com_accuracy_l1 <- function(A,X,K,alpha,r,q,e,eps=1e-3){
res.cov = cov_cluster(A,X,K,alpha,r,q,e)
l1.cov = norm(Pi-res.cov$Pi,"1")
return(l1.cov)
}
res.cv = lapply(alpha_seq,com_accuracy_l1,A=A,X=X,K=K,r=r,q=q,e=e)
alpha_seq
com_accuracy_l1 <- function(alpha,A,X,K,r,q,e,eps=1e-3){
res.cov = cov_cluster(A,X,K,alpha,r,q,e)
l1.cov = norm(Pi-res.cov$Pi,"1")
return(l1.cov)
}
res.cv = lapply(alpha_seq,com_accuracy_l1,A=A,X=X,K=K,r=r,q=q,e=e)
lapply(alpha_seq,square)
lapply(alpha_seq,pmax,.5)
sapply(alpha_seq,pmax,.5)
res.cv = sapply(alpha_seq,com_accuracy_l1,A=A,X=X,K=K,r=r,q=q,e=e)
res.cv = sapply(list(alpha_seq),com_accuracy_l1,A=A,X=X,K=K,r=r,q=q,e=e)
res.cv = sapply(c(alpha_seq),com_accuracy_l1,A=A,X=X,K=K,r=r,q=q,e=e)
res.cv = sapply(as.vector(alpha_seq),com_accuracy_l1,A=A,X=X,K=K,r=r,q=q,e=e)
?sapply
str(alpha_seq)
res.cv = sapply(alpha_seq,com_accuracy_l1,A=A,X=X,K=K,r=r,q=q,e=e)
?alpha_seq
com_accuracy_l1 <- function(alpha){
res.cov = cov_cluster(A,X,K,alpha,r,q,e,eps=1e-3)
l1.cov = norm(Pi-res.cov$Pi,"1")
return(l1.cov)
}
res.cv = sapply(alpha_seq,com_accuracy_l1)
install.packages(future.apply)
install.packages("future.apply")
library(future.apply)
res.cc = future_sapply(alpha,seq,com_accuracy_l1)
res.cc = future_lapply(alpha,seq,com_accuracy_l1)
library(plyr)
library(tidyverse)
res.cc = ldply(alpha,seq,com_accuracy_l1)
install.packages(plyr)
install.packages("plyr)
""
end
)
abc
))
")
intall.packages("plyr")
install.packages("plyr")
library(plyr)
?ldply
res.cc = ldply(alpha,seq,com_accuracy_l1,.parallel=T)
res.cc = future_lapply(alpha,seq,com_accuracy_l1)
res.cc = future_lapply(alpha_seq,com_accuracy_l1)
?transpose
library(Rfast)
res.cc = future_lapply(alpha_seq,com_accuracy_l1)
transpose = Rfast::transpose
res.cc = future_lapply(alpha_seq,com_accuracy_l1)
# source("gom_jml_mod.R")
plan(multiprocess)
# source("gom_jml_mod.R")
plan(multisession)
res.cc = future_lapply(alpha_seq,com_accuracy_l1)
warnings()
res.cc = future_lapply(alpha_seq,com_accuracy_l1,future.seed = T)
head(res.cc)
res.cc = future_sapply(alpha_seq,com_accuracy_l1,future.seed = T)
head(res.cc)
head(res.cv)
library(ggplot2)
plot(alpha_seq,res.cc)
plot(alpha_seq,res.cv)
l1.cov = norm(Pi-res.cov$Pi,"1")
com_accuracy_l1 <- function(alpha){
res.cov = cov_cluster(A,X,K,alpha,r,q,e,eps=1e-3)
l1.cov = norm(Pi-res.cov$Pi,"1")
for (i in 2:nrow(idx.all)) {
l1.tmp = norm(Pi-res.cov$Pi[,idx.all[i,]],"1")
if (l1.tmp < l1.cov){
l1.cov = l1.tmp
}
}
return(l1.cov)
}
res.cv = future_sapply(alpha_seq,com_accuracy_l1,future.seed = T)
plot(alpha_seq,res.cv)
com_accuracy_l2 <- function(alpha){
res.cov = cov_cluster(A,X,K,alpha,r,q,e,eps=1e-3)
l2.cov = norm(Pi-res.cov$Pi,"2")
for (i in 2:nrow(idx.all)) {
l2.tmp = norm(Pi-res.cov$Pi[,idx.all[i,]],"2")
if (l2.tmp < l2.cov){
l2.cov = l2.tmp
}
}
return(l2.cov)
}
res.cv2 = future_sapply(alpha_seq,com_accuracy_l1,future.seed = T)
plot(alpha_seq,res.cv2)
res.cv2 = future_sapply(alpha_seq,com_accuracy_l2,future.seed = T)
plot(alpha_seq,res.cv2)
plot(alpha_seq,res.cv,"l")
plot(alpha_seq,res.cv2,"l")
plot(alpha_seq,within_var)
plot(alpha_seq,within_var,"l")
dat = data.frame(cbind(alpha_seq,within_var,res.cv,res.cv2))
colnames(dat) = c("alpha","Var","L1","L2")
dat = dat %>% pivot_longer("Var":"L2",names_to = "type", values_to = "value")
ggplot(data=dat)+
geom_line(aes(x=alpha,y=value,col="type"))
ggplot(data=dat)+
geom_line(aes(x=alpha,y=value,group="type"))
ggplot(data=dat)+
geom_line(aes(x=alpha,y=value,group=type))
ggplot(data=dat)+
geom_line(aes(x=alpha,y=value,col=type))
dat = data.frame(cbind(alpha_seq,within_var,res.cv,res.cv2))
colnames(dat) = c("alpha","Var","L1","L2")
std_max = function(l){
return(l/max(l))
}
dat = apply(dat,2,std_max)
dat = dat %>% pivot_longer("Var":"L2",names_to = "type", values_to = "value")
dat
dat = dat %>% pivot_longer("Var":"L2",names_to = "type", values_to = "value")
dat = cbind(within_var,res.cv,res.cv2)
std_max = function(l){
return(l/max(l))
}
dat = apply(dat,2,std_max)
dat = data.frame(cbind(alpha_seq,dat))
colnames(dat) = c("alpha","Var","L1","L2")
dat = dat %>% pivot_longer("Var":"L2",names_to = "type", values_to = "value")
ggplot(data=dat)+
geom_line(aes(x=alpha,y=value,col=type))
dat = cbind(within_var,res.cv,res.cv2)
std_max = function(l){
return((l-min(l))/(max(l)-min(l)))
}
dat = apply(dat,2,std_max)
dat = data.frame(cbind(alpha_seq,dat))
colnames(dat) = c("alpha","Var","L1","L2")
dat = dat %>% pivot_longer("Var":"L2",names_to = "type", values_to = "value")
ggplot(data=dat)+
geom_line(aes(x=alpha,y=value,col=type))
find_best_idx <- function(idx,Pi,Pi.r,eps=1e-3,type="1"){
norm(Pi.r-Pi[,idx])
}
res.null = null_cluster(A,K,r,q,e)
apply(idx.all,1,find_best_idx,Pi=res.null$Pi,Pi.r=Pi)
find_best_alpha <- function(alpha,A,X,nstart,iter.max){
L.cov = mat.mult(A,transpose(A))+alpha*mat.mult(X,transpose(X))
L.all = Diag.fill(L.cov,0)
evd.all = eigs(L.all,k=K)
kmeans.all = kmeans(evd.all$vectors,K,algorithm = "Lloyd", nstart = nstart,iter.max = iter.max)
within_var[i] = kmeans.all$tot.withinss
return(kmeans.all$tot.withinss)
}
within_var = future_sapply(alpha_seq,find_best_alpha,A=A,X=X,nstart=3,iter.max=100)
within_var = future_sapply(alpha_seq,find_best_alpha,A,X,3,100)
warnings
warnings()
within_var = future_sapply(alpha_seq,find_best_alpha,A,X,3,100,future.seed=T)
