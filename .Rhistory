}
X.tmp=t(apply(X,1,samp_gen,d=d,A=A,sigmax=sigmax))
W = W * exp(dnorm(y[1,t],X.tmp[,1],sigmay,log = T)+
dnorm(y[2,t],X.tmp[,2],sigmay,log = T))
w = W/sum(W)
if (any(is.na(w))){
return(list(estimate=NA,rejuvs=rejuvs))
}
w.est = log(mean(W))+w.est
return(list(estimate=w.est,rejuvs=rejuvs))
}
pilot_gen <- function(x,num_pilot,A,sigmax){
rmvnorm(num_pilot,A%*%x,diag(sigmax^2,d))
}
wt_cal.first <- function(X,i,y,sigmay){
apply(X,1,wt_cal.last,i,y,sigmay)
}
wt_cal.last <- function(x,i,y,sigmay){
exp(dnorm(y[1,i],x[1],sigmay,log = T)+
dnorm(y[2,i],x[2],sigmay,log = T))
}
smc_zero <- function(n,d,t,A,sigmax,sigmay,y,num_pilot){
w.estimate = 0
rejuvs = 0
X = matrix(rnorm(n*d,0,sigmax),nrow=n)
W = exp(dnorm(y[1,1],X[,1],sigmay,log = T)+
dnorm(y[2,1],X[,2],sigmay,log = T))
W.u = W
w = W.u/sum(W.u)
w.estimate = log(mean(W))
for (i in 2:t) {
# Resampling
x.tmp = array(rep(0,n*num_pilot*d),c(n,num_pilot,d))
W.mat.tmp = matrix(rep(0,n*num_pilot),nrow=n)
tmp=t(apply(X,1,pilot_gen,num_pilot,A,sigmax)) # column1 and 11 correspond to the first row
x.tmp[,,1] = tmp[,1:num_pilot]
x.tmp[,,2] = tmp[,(num_pilot+1):(2*num_pilot)]
W.mat.tmp = t(apply(x.tmp,1,wt_cal.first,i,y,sigmay))
W.tmp = rowMeans(W.mat.tmp)
w.mat.tmp = W.u*W.mat.tmp/sum(W.u*W.mat.tmp)
norm_const = sum(W.u*W.tmp)/sum(W.u)
cri = sum(w.mat.tmp*(w/mean(w)*W.mat.tmp/norm_const-W.mat.tmp/norm_const))
if (cri > 0){
idx = resresample(w)
X = X[idx,]
W.u = rep(1,n)
rejuvs = rejuvs+1
w = W.u/sum(W.u)
}
W.p = W.u
X.tmp=t(apply(X,1,samp_gen,d=d,A=A,sigmax=sigmax))
W = exp(dnorm(y[1,i],X.tmp[,1],sigmay,log = T)+
dnorm(y[2,i],X.tmp[,2],sigmay,log = T))
W.u = W.u*W
w = W.u/sum(W.u)
w.estimate = w.estimate+log(sum(W.u))-log(sum(W.p))
if (any(is.na(w))){
return(list(estimate=NA,rejuvs=rejuvs))
}
X = X.tmp
}
return(list(estimate=w.estimate,rejuvs=rejuvs))
}
smc_wt <- function(n,d,t,A,sigmax,sigmay,y,num_pilot){
w.estimate = 0
rejuvs = 0
X = matrix(rnorm(n*d,0,sigmax),nrow=n)
W = exp(dnorm(y[1,1],X[,1],sigmay,log = T)+
dnorm(y[2,1],X[,2],sigmay,log = T))
W.u = W
w = W.u/sum(W.u)
w.estimate = log(mean(W))
# Resampling
for (i in 2:t) {
x.tmp = array(rep(0,n*num_pilot*d),c(n,num_pilot,d))
W.mat.tmp = matrix(rep(0,n*num_pilot),nrow=n)
tmp=t(apply(X,1,pilot_gen,num_pilot,A,sigmax)) # column1 and 11 correspond to the first row
x.tmp[,,1] = tmp[,1:num_pilot]
x.tmp[,,2] = tmp[,(num_pilot+1):(2*num_pilot)]
W.mat.tmp = t(apply(x.tmp,1,wt_cal.first,i,y,sigmay))
W.tmp = rowMeans(W.mat.tmp)
norm_const = sum(W.u*W.tmp)/sum(W.u)
phi.mat = W.mat.tmp
w.mat.tmp = W.u*W.mat.tmp/sum(W.u*W.mat.tmp)
meanphi = sum(w.mat.tmp*phi.mat)
barphi.mat = phi.mat-meanphi
mgphi = rowMeans(W.mat.tmp/(norm_const+1e-14)*barphi.mat)
res.all = W.u/mean(W.u)
res.all = (res.all-trunc(res.all))/(res.all+1e-14)
res.1 = sum((mgphi)^2*res.all*w)
res.2 = 1/(sum(w*res.all))*sum(w.mat.tmp*res.all*barphi.mat)^2
cri = sum(w.mat.tmp*barphi.mat^2*(w/mean(w)*W.mat.tmp/norm_const-
W.mat.tmp/norm_const))+res.2-res.1
if (cri > 0){
idx = resresample(w)
X = X[idx,]
W.u = rep(1,n)
rejuvs = rejuvs+1
w = W.u/sum(W.u)
}
W.p = W.u
X.tmp=t(apply(X,1,samp_gen,d=d,A=A,sigmax=sigmax))
W = exp(dnorm(y[1,i],X.tmp[,1],sigmay,log = T)+
dnorm(y[2,i],X.tmp[,2],sigmay,log = T))
W.u = W.u*W
w = W.u/sum(W.u)
w.estimate = w.estimate+log(sum(W.u))-log(sum(W.p))
if (any(is.na(w))){
return(list(estimate=NA,rejuvs=rejuvs))
}
}
return(list(estimate=w.estimate,rejuvs=rejuvs))
}
resamp_var <- function(resamp_wt,mgphi,EY){
sum(resamp_wt*(mgphi)^2)-2*sum(resamp_wt*mgphi)*EY+EY^2
}
smc_wt_mat <- function(n,d,t,A,sigmax,sigmay,y,num_pilot){
w.estimate = 0
rejuvs = 0
X = matrix(rnorm(n*d,0,sigmax),nrow=n)
W = exp(dnorm(y[1,1],X[,1],sigmay,log = T)+
dnorm(y[2,1],X[,2],sigmay,log = T))
W.u = W
w = W.u/sum(W.u)
w.estimate = log(mean(W))
for (i in 2:t) {
# Resampling
resamp_mat = str_mat(w)
x.tmp = array(rep(0,n*num_pilot*d),c(n,num_pilot,d))
W.mat.tmp = matrix(rep(0,n*num_pilot),nrow=n)
tmp=t(apply(X,1,pilot_gen,num_pilot,A,sigmax)) # column1 and 11 correspond to the first row
x.tmp[,,1] = tmp[,1:num_pilot]
x.tmp[,,2] = tmp[,(num_pilot+1):(2*num_pilot)]
W.mat.tmp = t(apply(x.tmp,1,wt_cal.first,i,y,sigmay))
W.tmp = rowMeans(W.mat.tmp)
norm_const = sum(W.u*W.tmp)/sum(W.u)
phi.mat = W.mat.tmp
w.mat.tmp = W.u*W.mat.tmp/sum(W.u*W.mat.tmp)
meanphi = sum(w.mat.tmp*phi.mat)
barphi.mat = phi.mat-meanphi
mgphi = rowMeans(W.mat.tmp/(norm_const+1e-14)*barphi.mat)
EY = mean(resamp_mat%*%mgphi)
var_resamp = mean(apply(resamp_mat,1,resamp_var,mgphi,EY))
cri = sum(w.mat.tmp*barphi.mat^2*(w/mean(w)*W.mat.tmp/norm_const-
W.mat.tmp/norm_const))-var_resamp
if (cri > 0){
idx = resresample(w)
X = X[idx,]
W.u = rep(1,n)
rejuvs = rejuvs+1
w = W.u/sum(W.u)
}
W.p = W.u
X.tmp=t(apply(X,1,samp_gen,d=d,A=A,sigmax=sigmax))
W = exp(dnorm(y[1,i],X.tmp[,1],sigmay,log = T)+
dnorm(y[2,i],X.tmp[,2],sigmay,log = T))
W.u = W.u*W
w = W.u/sum(W.u)
w.estimate = w.estimate+log(sum(W.u))-log(sum(W.p))
}
return(list(estimate=w.estimate,rejuvs=rejuvs))
}
num_pilots = 10
dat = lg_gen(d,t,A,sigmax,sigmay)
x = dat$x
y = dat$y
boot = smc_boot(n,d,t,A,sigmax,sigmay,y)
zero = smc_zero(n,d,t,A,sigmax,sigmay,y,num_pilots)
wt = smc_wt(n,d,t,A,sigmax,sigmay,y,num_pilots)
warnings()
setwd("D:/Programmes/smcresampfreq/LG")
load("MLGS_log.RData")
head(res)
mse.boot = rep(0,p)
mse.zero = rep(0,p)
mse.wt = rep(0,p)
rejuvs = rep(0,3)
for (i in 1:p) {
mse.boot[i] = res[i,]$boot
mse.zero[i] = res[i,]$zero
mse.wt[i] = res[i,]$wt
rejuvs = rejuvs + res[i,]$rejuvs
}
mse.boot = rep(0,p)
mse.zero = rep(0,p)
mse.wt = rep(0,p)
mse.mat = rep(0,p)
rejuvs = rep(0,4)
for (i in 1:p) {
mse.boot[i] = res[i,]$boot
mse.zero[i] = res[i,]$zero
mse.wt[i] = res[i,]$wt
mse.mat[i] = res[i,]$mat
rejuvs = rejuvs + res[i,]$rejuvs
}
rejuvs = rejuvs/p
rejuvs
# idx = mse.boot==0 | mse.zero==0 | mse.wt==0
mse.res = data.frame(mse.boot,mse.wt,mse.mat,mse.zero)
colnames(mse.res) = c("Boot","Wt","Mat","Zero")
mse.res = mse.res[!idx,]
# mse.res = mse.res[!idx,]
mse.res$idx = 1:nrow(mse.res)
library(tidyverse)
mse.n = mse.res %>% pivot_longer("Boot":"Zero",names_to = "type", values_to = "mse")
ggplot(mse.n) +
geom_boxplot(aes(y=mse,fill=type))
mse.n %>% group_by(type) %>% summarise(type_median=median(mse))
load("MLGR_log.RData")
head(res)
mse.boot = rep(0,p)
mse.zero = rep(0,p)
mse.wt = rep(0,p)
rejuvs = rep(0,3)
for (i in 1:p) {
mse.boot[i] = res[i,]$boot
mse.zero[i] = res[i,]$zero
mse.wt[i] = res[i,]$wt
rejuvs = rejuvs + res[i,]$rejuvs
}
rejuvs = rejuvs/p
idx = mse.boot==0 | mse.zero==0 | mse.wt==0
mse.res = data.frame(mse.boot,mse.wt,mse.zero)
colnames(mse.res) = c("Boot","Wt","Zero")
mse.res$idx = 1:p
library(tidyverse)
mse.n = mse.res %>% pivot_longer("Boot":"Zero",names_to = "type", values_to = "mse")
# mse.n$mse = log(mse.n$mse)
ggplot(mse.n) +
geom_boxplot(aes(y=mse,fill=type))
rejuvs
mse.n %>% group_by(type) %>% summarise(type_median=median(mse))
res$rejuvs
res[1,]$rejuvs
res[2,]$rejuvs
library(RSpectra)
library(Rfast)
library(Matrix)
library(gtools)
library(sirt)
library(future.apply)
library(FNN)
plan(multisession)
## data generation
K = 3
N = 500
p = N/5
R = 2
idx.all = permutation(1:K)
pi_gen <- function(pi,K){
pi = rdirichlet(1,rep(1,K))
return(pi)
}
set.seed(230627)
Pi = matrix(rep(0,N*K),nrow=N)
Pi = t(apply(Pi,1,pi_gen,K=K))
Theta = matrix(runif(p*K),ncol=K)
M = matrix(rnorm(R*K),nrow=R)
Pi[1:K,] = diag(rep(1,K))
A_t = Pi%*%t(Theta)
X_t = Pi%*%t(M)
A = matrix(rbinom(N*p,1,A_t),nrow = N)
X = X_t + matrix(rnorm(N*R,0,.7),nrow=N)
## tuning parameter (The choice is still undecided)
alpha = .1
## functions
Prune <- function(U,r,q,e){
l = apply(U,1,norm,"2")
quan.l = quantile(l,1-q)
P0 = which(l>=quan.l)
U0 = U[P0,]
x = rowmeans(knnx.dist(U,U0,r))
quan.x = quantile(x,1-e)
P = which(x>quan.x)
P = P0[P]
return(P)
}
find_act <- function(s,P){
s+sum(P<s)
}
null_cluster <- function(A,K,r,q,e,eps=1e-3){
svd.A = svds(A,K)
P = Prune(svd.A$u,r,q,e)
IK = Diag.matrix(K,1)
S = c()
U = svd.A$u
Y0 = U[-P,]
Y = Y0
for (k in 1:K) {
l = apply(Y,1,norm,"2")
S = c(S,which.max(l))
u = Y[S[k],]/norm(Y[S[k],],"2")
u = data.matrix(u)
Y = mat.mult(Y,IK-mat.mult(u,transpose(u)))
}
US = Y0[S,]
Pi = mat.mult(U,solve(US))
Pi = pmax(Pi,0)
Pi = mat.mult(diag((rowsums(Pi)+1e-14)^(-1)),Pi)
Theta = mat.mult(mat.mult(mat.mult(mat.mult(svd.A$v,diag(svd.A$d)),transpose(svd.A$u)),Pi),spdinv(mat.mult(transpose(Pi),Pi)))
Theta = pmin(Theta,1-eps)
Theta = pmax(Theta,eps)
S = lapply(S,find_act,P)
return(list(Pi=Pi,Theta=Theta,S=S))
}
cov_cluster <- function(A,X,K,alpha,r,q,e,eps=1e-3){
L = mat.mult(A,transpose(A))+alpha*mat.mult(X,transpose(X))
L = Diag.fill(L,0)
evd.A = eigs(L,K)
P = Prune(evd.A$vectors,r,q,e)
IK = Diag.matrix(K,1)
U = evd.A$vectors
S = c()
Y0 = U[-P,]
Y = Y0
for (k in 1:K) {
l = apply(Y,1,norm,"2")
S = c(S,which.max(l))
u = Y[S[k],]/norm(Y[S[k],],"2")
u = data.matrix(u)
Y = mat.mult(Y,IK-mat.mult(u,transpose(u)))
}
US = Y0[S,]
Pi = mat.mult(U,solve(US))
Pi = pmax(Pi,0)
Pi = mat.mult(diag((rowsums(Pi)+1e-14)^(-1)),Pi)
svd.A = svds(A,K)
Theta = mat.mult(mat.mult(mat.mult(mat.mult(svd.A$v,diag(svd.A$d)),transpose(svd.A$u)),Pi),spdinv(mat.mult(transpose(Pi),Pi)))
Theta = pmin(Theta,1-eps)
Theta = pmax(Theta,eps)
S = lapply(S,find_act,P)
return(list(Pi=Pi,Theta=Theta,S=S))
}
find_best_idx <- function(idx,Pi,Pi.r,type="1"){
norm(Pi.r-Pi[,idx],type = type)
}
find_best_alpha <- function(alpha,A,X,K,type="2",r=10,q=0.4,e=0.2,eps=1e-3,nfold=5){
## create K-fold missing matrix
n = nrow(A)
idx.A = rep(1:nfold,length.out=nrow(A)*ncol(A))
idx.X = rep(1:nfold,length.out=nrow(X)*ncol(X))
idx.A = sample(idx.A)
idx.X = sample(idx.X)
err = rep(0,nfold)
for (kk in 1:nfold) {
A.tmp = A
X.tmp = X
bool_mat.A = matrix(idx.A == kk,nrow=n)
bool_mat.X = matrix(idx.X == kk,nrow=n)
A.tmp[as.logical(bool_mat.A)] = 0
X.tmp[as.logical(bool_mat.X)] = 0
cov.tmp = cov_cluster(A.tmp,X.tmp,K,alpha,r,q,e,eps)
A.est = mat.mult(cov.tmp$Pi,transpose(cov.tmp$Theta))
# err[kk] = mean(abs(A[bool_mat.A]-A.est[bool_mat.A]))
err[kk] = norm(A-A.est,"2")
}
return(mean(err))
}
find_best_alpha2 <- function(alpha,A,X,K,type="2",r=10,q=0.4,e=0.2,eps=1e-3,nfold=5){
## create K-fold missing matrix
n = nrow(A)
idx.A = rep(1:nfold,length.out=nrow(A)*ncol(A))
idx.X = rep(1:nfold,length.out=nrow(X)*ncol(X))
idx.A = sample(idx.A)
idx.X = sample(idx.X)
err = rep(0,nfold)
for (kk in 1:nfold) {
A.tmp = A
X.tmp = X
bool_mat.A = matrix(idx.A == kk,nrow=n)
bool_mat.X = matrix(idx.X == kk,nrow=n)
A.tmp[as.logical(bool_mat.A)] = 0
X.tmp[as.logical(bool_mat.X)] = 0
cov.tmp = cov_cluster(A.tmp,X.tmp,K,alpha,r,q,e,eps)
A.est = mat.mult(cov.tmp$Pi,transpose(cov.tmp$Theta))
U.est = svds(A.est,K)$u
U = svds(A,K)$u
# err[kk] = mean(abs(A[bool_mat.A]-A.est[bool_mat.A]))
# err[kk] = norm(U-U.est,"2")
err[kk] = mean(abs(U-U.est))
}
return(mean(err))
}
.gom.self.proc <- function(A,K){
A.resp = 1-is.na(A)
N = nrow(A)
J = ncol(A)
score = rowsums(A)/rowsums(A.resp)
theta0 = seq(-1.5,1.5,len=K)
Pi = transpose(exp(-(Outer(stats::qlogis((score+.1)/1.2),theta0,"-"))^2))
Pi = Pi/rowsums(Pi)
p.item = colsums(A)/colsums(A.resp)
theta0 = seq(-2,2,len=K)
Theta = stats::plogis(Outer(theta0,-stats::qlogis(p.item),"-"))
res = list(Pi=Pi,Theta=Theta)
return(res)
}
.gom.self.deviance <- function(Pi,Theta,K,A){
prob0 = prob1 = 0
for (k in 1:K) {
prob1 = prob1 + Outer(Pi[,k],Theta[,k])
prob0 = prob0 + Outer(Pi[,k],1-Theta[,k])
}
dev = -2*sum(log(A*transpose(prob1)+(1-A)*transpose(prob0)))
return(dev)
}
gom.jml.self <- function(A,K,max.iter=600,eps=1e-3){
datproc = .gom.proc(A,K)
Pi = datproc$Pi
Theta = datproc$Theta
iter = 0
conv = 10
devchange = -100
dev = .gom.deviance(Pi,Theta,K,A)
while (((eps<devchange)|(eps<conv))&(iter<max.iter)) {
Pi.t = Pi
Theta.t = Theta
dev.t = dev
Pi = Pi.t*(mat.mult(A/(mat.mult(Pi.t,transpose(Theta.t))+1e-14),Theta.t)+
mat.mult((1-A)/(mat.mult(Pi.t,transpose(1-Theta.t))+1e-14),1-Theta.t))/ncol(A)
Pi = pmax(Pi,eps)
Pi = pmin(Pi,1-eps)
Theta.rev = 1-Theta.t
Theta = Theta.t*mat.mult(transpose(A/(mat.mult(Pi,transpose(Theta.t))+1e-14)),Pi)
Theta.rev = Theta.rev*mat.mult(transpose((1-A)/(mat.mult(Pi,transpose(Theta.rev))+1e-14)),Pi)
Theta = Theta/(Theta+Theta.rev)
Theta = pmin(Theta,1-eps)
Theta = pmax(Theta,eps)
dev = .gom.deviance(Pi,Theta,K,A)
conv = max(max(abs(Pi-Pi.t)),max(abs(Theta-Theta.t)))
devchange = abs((dev-dev.t)/dev)
iter = iter + 1
}
return(list(Pi=Pi,Theta=Theta,iter=iter))
}
## diag deletion
r = 10
q = .4
e = .2
com_accuracy_l2 <- function(alpha){
res.cov = cov_cluster(A,X,K,alpha,r,q,e,eps=1e-3)
l2.cov1 = apply(idx.all,1,find_best_idx,Pi=res.cov$Pi,Pi.r=Pi,type="2")
# l2.cov2 = norm(Theta-res.cov$Theta[,idx.all[which.min(l2.cov1)]],"2")
# l2.cov = min(l2.cov1)+l2.cov2
l2.cov = min(l2.cov1)
return(l2.cov)
}
com_accuracy_l2_all <- function(alpha){
res.cov = cov_cluster(A,X,K,alpha,r,q,e,eps=1e-3)
l2.cov1 = apply(idx.all,1,find_best_idx,Pi=res.cov$Pi,Pi.r=Pi,type="2")
l2.cov2 = norm(Theta-res.cov$Theta[,idx.all[which.min(l2.cov1)]],"2")
l2.cov = min(l2.cov1)+l2.cov2
# l2.cov = min(l2.cov1)
return(l2.cov)
}
com_accuracy_l2_A <- function(alpha){
res.cov = cov_cluster(A,X,K,alpha,r,q,e,eps=1e-3)
A.est = mat.mult(res.cov$Pi,transpose(res.cov$Theta))
# l2.cov1 = apply(idx.all,1,find_best_idx,Pi=res.cov$Pi,Pi.r=Pi,type="2")
# l2.cov2 = norm(Theta-res.cov$Theta[,idx.all[which.min(l2.cov1)]],"2")
l2.cov = norm(A-A.est,"2")
# l2.cov = min(l2.cov1)
return(l2.cov)
}
res.cv = future_sapply(alpha_seq,com_accuracy_l2,future.seed=T)
AA = mat.mult(A,transpose(A))
AA = Diag.fill(AA,0)
XX = mat.mult(X,transpose(X))
XX = Diag.fill(XX,0)
AA.evd = eigs(AA,K+1)
XX.evd = eigs(XX,K+1)
alpha_min = (AA.evd$values[K]-AA.evd$values[K+1])/XX.evd$values[1]
if (R<K){
# alpha_max = (AA.evd$values[1])/(XX.evd$values[R])
alpha_max = AA.evd$values[K]/XX.evd$values[R]
} else {
alpha_max = (AA.evd$values[K])/(XX.evd$values[K]-XX.evd$values[K+1])
}
# alpha_max = (AA.evd$values[K]-AA.evd$values[K+1])/XX.evd$values[R]
alpha_seq = seq(from=0,to=alpha_max,length=100)# fail sometimes
res.cv = future_sapply(alpha_seq,com_accuracy_l2,future.seed=T)
plot(alpha_seq,res.cv,"l")
res.cv1 = future_sapply(alpha_seq,com_accuracy_l2_all,future.seed=T)
res.cv2 = future_sapply(alpha_seq,com_accuracy_l2_A,future.seed=T)
plot(alpha_seq,res.cv2,"l")
plot(alpha_seq,res.cv1,"l")
err = future_sapply(alpha_seq,find_best_alpha,A,X,K,future.seed=T)
plot(alpha_seq,err,"l",col="red")
ggplot()+
geom_smooth(aes(alpha_seq,err))+
geom_line(aes(alpha_seq,err))
err1 = future_sapply(alpha_seq,find_best_alpha,A,X,K,future.seed=T)
ggplot()+
geom_smooth(aes(alpha_seq,err1))+
geom_line(aes(alpha_seq,err1))
err2 = future_sapply(alpha_seq,find_best_alpha,A,X,K,future.seed=T)
ggplot()+
geom_smooth(aes(alpha_seq,err2))+
geom_line(aes(alpha_seq,err2))
err3 = future_sapply(alpha_seq,find_best_alpha,A,X,K,future.seed=T)
ggplot()+
geom_smooth(aes(alpha_seq,err3))+
geom_line(aes(alpha_seq,err3))
library(data.table)
library(R.utils)
transpose = Rfast::transpose
dat = fread("../data/GSM5238385_ME11_50um.fragments.tsv.gz")
spac = fread("../data/GSM5238385_ME11_50um_spatial.tar.gz")
setwd("D:/Programmes/Covariate-Assisted-Spectral-GoM")
dat = fread("../data/GSM5238385_ME11_50um.fragments.tsv.gz")
spac = fread("../data/GSM5238385_ME11_50um_spatial.tar.gz")
View(dat)
